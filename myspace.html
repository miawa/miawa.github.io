<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>My Space</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script type="module" src="myspace.js" defer></script>
  <script type="module" src="draggableElements.js" defer></script>
  <link href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>

  
  <link rel="stylesheet" href="myspacestylesheet.css" />
</head>

<body>
  <div id="pageWrapper"> <!-- NEW wrapper to control layout -->
     <div id="profileHeader"></div> <!-- NEW black header -->
   
  <div id="container">

 
    <div class="background-container"></div>
    <div class="profile-picture-wrapper">
        <img id="profilePicture" src="default-profile.jpg" alt="Profile Picture" />
      </div>
  <div class = "profile-info-container">
    <main>

      
      <p class = "userBody" id="usernameDisplay"></p> 
      <p class = "userBody" id="displayName"></p>

    
  <div class="friend-card">
    <div class="stats-section">
   <div class="stat" id = "friendsStat" style = "cursor: pointer;">
    <span class="stat-number" id="friendsCount">0</span>
    <span class="stat-label">Friends</span>
  </div>
  <div class="stat">
    <span class="stat-number" id="followersCount">0</span>
    <span class="stat-label">Followers</span>
  </div>
  <div class="stat">
    <span class="stat-number" id="postsCount">0</span>
    <span class="stat-label">Posts</span>
  </div>
</div>
</div>

<button id="editProfileBtn" class="edit-profile-button">Edit Profile</button>


<div class="modal" id="friendsModal" style ="display: none;">
  <div class="modal-content">
    <h2>Friends</h2>
     <div id="friendsList" style="display: flex; gap: 15px; flex-wrap: wrap;"></div>
    <button class="close-button" id="closeModal">Close</button>
  </div>
</div>

<div class="bio-separator"></div>
      <p class = "userBody" id="bio"></p>

      <br />
      <br />


     

     
      <button type="button" id="changeButton">Change Profile Picture</button>
      <button type="button" id="changeBackgroundButton">Change Background Image</button>
      <input type="file" id="backgroundFileInput" accept="image/*" hidden />

      <input type="file" id="fileInput" accept="image/*" hidden />
      <section id="friendsSection">
      

    <div id="postTabs" style="margin-top: 20px; display: flex; gap: 20px; cursor: pointer;">
    <div class="tab active" data-tab="posts">Posts</div>
    <div class="tab" data-tab="feed">Feed</div>
    <div class="tab" data-tab="profile">Profile</div>
    </div>

    </div>
  <div id="feedContainer">
  <!-- feed content will load here -->
</div>


    <div id="postsContainer" style="margin-top: 20px;"></div>
    <button class="fab" id="fab">+</button>

   
</div>

<div id="editMusicPopup" style="display:none; position: fixed; top:50%; left:50%; 
  transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; z-index: 10001; box-shadow: 0 4px 12px rgba(0,0,0,0.3); width: 320px;">
  <h3>Edit Profile Music</h3>
  
  <label>Artist Name:</label><br />
  <input type="text" id="artistName" placeholder="Artist Name" /><br /><br />
  
  <label>Album Name:</label><br />
  <input type="text" id="albumName" placeholder="Album Name" /><br /><br />
  
  <label>Track Name:</label><br />
  <input type="text" id="trackName" placeholder="Track Name" /><br /><br />
  
  <label>Album Cover Image:</label><br />
  <input type="file" id="albumCoverInput" accept="image/*" /><br /><br />
  
  
  <button id="submitMusicBtn">Upload Music</button>
  <button id="closeMusicPopupBtn" style="margin-left:10px;">Cancel</button>
</div>

<div id="editProfilePopup" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
  background:white; border:1px solid #ccc; padding:20px; z-index:10000; box-shadow:0 2px 10px rgba(0,0,0,0.2);">
  <h3>Edit Profile</h3>
  <button id="editProfilePicBtn">Edit Profile Picture</button>
  <button id="editBackgroundBtn">Edit Background</button>
  <button id="editProfileSong">Edit Profile Song</button>
  <button id="closeEditProfilePopupBtn" style="margin-top:10px;">Close</button>
</div>

<div id="popupOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; 
  background: rgba(0,0,0,0.5); z-index:9999;"></div>



   

    <div id="profileContainer">
  <!-- profile content here -->
</div>


    <div id="sideMenu">
  <div id="menuTab">‚ò∞</div>  <!-- the tab visible always -->
  <div id="menuContent">
    <a href="#">Home</a>
    <a href="#">Settings</a>
  </div>
</div>



<div class="fab-options" id="fabOptions">
  <button class="fab-option-btn" id="newTextPostBtn">üìÑ Text Post</button>
  <button class="fab-option-btn" id="newImagePostBtn">üñºÔ∏è Content Post</button>
</div>
<div id="bottomHeader">
  <button class="fab" id="fab">+</button>
</div>


<!-- Post Form -->
<!-- Post Form -->
<div id="postForm" style="display: none;">
  <textarea id="postText" placeholder="What's on your mind?"></textarea>

  <!-- Image Preview (Cropped or Original Image) -->
  <div id="imagePreviewContainer" style="margin-top: 10px;"></div>

  <!-- Hidden File Input -->
  <input type="file" id="postImageInput" accept="image/*" style="display: none;" />
  <input type="file" id="musicFileInput" accept="audio/*" hidden />


  <!-- Cropper Area (Shown only when cropping) -->
  <div id="cropperContainer" style="max-width: 400px; max-height: 400px; display: none; margin-top: 10px;">
    <img id="imageToCrop" src="" alt="Crop your image" style="max-width: 100%;" />
    <button id="cropImageBtn">Crop & Use Image</button>
  </div>

 


  <!-- Post & Cancel Buttons -->
  <div style="margin-top: 10px;">
    <button id="submitPostBtn">Post</button>
    <button id="cancelPostBtn">Cancel</button>
  </div>
</div>
  

  </section> 
</section>
    </main>

    <footer>
      <!-- Footer content -->
    </footer>

    <script type="module">
      import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'
      import { uploadDraggableImage, saveDraggableImage, loadSingleImage, loadDraggableImages } from './draggableElements.js';
     


      const supabaseUrl = 'https://fctswjvfkyolhiyzhusb.supabase.co';
      const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZjdHN3anZma3lvbGhpeXpodXNiIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0OTU3ODI2MiwiZXhwIjoyMDY1MTU0MjYyfQ.CAsDZEtYPa9e1hKmufSsofDkAXC1AFLeEk2bN50Gad0'; // Replace with your anon key
      const supabase = createClient(supabaseUrl, supabaseKey);

      const userId = localStorage.getItem('userId');

      const friendsStat = document.getElementById('friendsStat');
  const friendsModal = document.getElementById('friendsModal');
  const closeModal = document.getElementById('closeModal');

      document.addEventListener('DOMContentLoaded', () => {
  const editProfileBtn = document.getElementById('editProfileBtn');
  const editProfilePopup = document.getElementById('editProfilePopup');
  const closePopupBtn = document.getElementById('closeEditProfilePopupBtn');
  const editProfileSong = document.getElementById('editProfileSong');
const editMusicPopup = document.getElementById('editMusicPopup');
  

  editProfileBtn.addEventListener('click', () => {
    editProfilePopup.style.display = 'block';

  });

  closePopupBtn.addEventListener('click', () => {
    editProfilePopup.style.display = 'none';
  });
});

  friendsStat.addEventListener('click', () => {
    console.log('Friends clicked');
    friendsModal.style.display = 'flex';
    loadFriends(userId);
  });
   editProfileSong.addEventListener('click', () => {
    editMusicPopup.style.display = 'block';
    editProfileSong.style.display = "none";
    musicFileInput.click();
  });
musicFileInput.addEventListener('change', async () => {
  const file = musicFileInput.files[0];
  if (!file) {
    alert('No music file selected');
    return;
  }

  try {
    // You can prompt the user for a title here, or use empty string
    const title = prompt('Enter a title for your profile music:', '') || '';
    const userId = localStorage.getItem('userId'); // or get from supabase.auth.user()?.id

    await uploadProfileMusic(file, title, userId);

    alert('Music uploaded successfully!');
  } catch (error) {
    alert('Error uploading music: ' + error.message);
  }
});
  closeModal.addEventListener('click', () => {
    friendsModal.style.display = 'none';
  });

      function editProfilePopup(){

  document.addEventListener('DOMContentLoaded', () => {
  const editProfileBtn = document.getElementById('editProfileBtn');
  const editProfilePopup = document.getElementById('editProfilePopup');
  const closePopupBtn = document.getElementById('closeEditProfilePopupBtn');
   const editProfileSong = document.getElementById('editProfileSong');

  editProfileBtn.addEventListener('click', () => {
    editProfilePopup.style.display = 'block';
  });

  closePopupBtn.addEventListener('click', () => {
    editProfilePopup.style.display = 'none';
  });

  // Optional: close popup when clicking outside the popup content
  window.addEventListener('click', (event) => {
    if (event.target === editProfilePopup) {
      editProfilePopup.style.display = 'none';
    }
  });
});

      }

let cropper; // keep this outside to access it across functions
let selectedImageFile = null; // store the cropped file globally

async function uploadProfileMusicWithDetails() {
  const artist = document.getElementById('artistName').value.trim();
  const album = document.getElementById('albumName').value.trim();
  const track = document.getElementById('trackName').value.trim();
  const albumCoverFile = document.getElementById('albumCoverInput').files[0];
  const musicFile = document.getElementById('musicFileInput').files[0];
  const userId = localStorage.getItem('userId');

  if (!artist || !album || !track || !albumCoverFile || !musicFile) {
    alert('Please fill all fields and select files.');
    return;
  }

  try {
    // Upload album cover image
    const coverFileExt = albumCoverFile.name.split('.').pop();
    const coverFileName = `${userId}/album_covers/${Date.now()}.${coverFileExt}`;

    const { error: coverUploadError } = await supabase.storage
      .from('profile-music-covers')
      .upload(coverFileName, albumCoverFile, { upsert: true });

    if (coverUploadError) throw coverUploadError;

    const { data: coverData, error: coverUrlError } = supabase.storage
      .from('profile-music-covers')
      .getPublicUrl(coverFileName);

    if (coverUrlError) throw coverUrlError;

    const albumCoverUrl = coverData.publicUrl;

    // Upload music file (reuse your existing upload logic slightly modified)
    const timestamp = Date.now();
    const musicFileExt = musicFile.name.split('.').pop();
    const musicFileName = `${userId}/${timestamp}.${musicFileExt}`;

    const { error: musicUploadError } = await supabase.storage
      .from('profile-music')
      .upload(musicFileName, musicFile, { upsert: true });

    if (musicUploadError) throw musicUploadError;

    const { data: musicData, error: musicUrlError } = supabase.storage
      .from('profile-music')
      .getPublicUrl(musicFileName);

    if (musicUrlError) throw musicUrlError;

    const musicUrl = musicData.publicUrl;

    // Insert full record into profile_music table
    const { error: insertError } = await supabase
      .from('profile_music')
      .insert([{
        user_id: userId,
        music_url: musicUrl,
        album_cover_url: albumCoverUrl,
        artist_name: artist,
        album_name: album,
        track_name: track,
        created_at: new Date().toISOString()
      }]);

    if (insertError) throw insertError;

    alert('Music and album details uploaded successfully!');
    editMusicPopup.style.display = 'none';

  } catch (error) {
    alert('Upload failed: ' + error.message);
    console.error(error);
  }
}

document.getElementById('submitMusicBtn').addEventListener('click', uploadProfileMusicWithDetails);

async function playProfileMusic(userId) {
  try {
    // Query the latest music for the user
    const { data, error } = await supabase
      .from('profile_music')
      .select('music_url')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    if (error) {
      console.error('Failed to fetch profile music:', error);
      return;
    }

    if (!data || !data.music_url) {
      console.log('No profile music found for user');
      return;
    }

    // Create audio element
    let audio = document.createElement('audio');
    audio.src = data.music_url;
    audio.autoplay = true;
    audio.controls = true;
    audio.loop = true; // optional: loop music
    audio.style.position = 'fixed'; // optional: fixed so it doesn't shift layout
    audio.style.bottom = '10px';
    audio.style.left = '10px';
    audio.style.zIndex = '10000';

    document.body.appendChild(audio);

    // Try to play (some browsers require interaction first)
    audio.play().catch(err => {
      console.warn('Autoplay prevented:', err);
    });

  } catch (err) {
    console.error('Error playing profile music:', err);
  }
}

// Call this once your userId is known and page is ready:
document.addEventListener('DOMContentLoaded', () => {
  const userId = localStorage.getItem('userId');
  if (userId) {
  //  playProfileMusic(userId);
  }
});

function setupImageCropper() {
  console.log("setupImagecropper called")
  const postImageInput = document.getElementById('postImageInput');
  const cropperContainer = document.getElementById('cropperContainer');
  const imageToCrop = document.getElementById('imageToCrop');
  const cropImageBtn = document.getElementById('cropImageBtn');
  const imagePreviewContainer = document.getElementById('imagePreviewContainer');

  // Remove previous event listeners if any (optional, for repeated calls)
  postImageInput.replaceWith(postImageInput.cloneNode(true));
  const newPostImageInput = document.getElementById('postImageInput');

  postImageInput.addEventListener('change', () => {
    console.log("file input changed")
    const file = postImageInput.files[0];
    if (file && file.type.startsWith('image/')) {
      console.log('File selected:', file.name);
      const reader = new FileReader();
      reader.onload = () => {
          // Show the cropper container
  cropperContainer.style.display = 'block';
        imageToCrop.src = reader.result;
        
      

        imageToCrop.onload = () => {
          if (cropper) cropper.destroy();
          cropper = new Cropper(imageToCrop, {
            aspectRatio: 1,
            viewMode: 1,
            autoCropArea: 1,
            responsive: true,
          });
          console.log('File selected:', file.name);

        };
        // Also show a quick preview for debugging
    imagePreviewContainer.innerHTML = `<img src="${reader.result}" style="max-width: 100%; max-height: 150px;" alt="Preview">`;
      };
      reader.readAsDataURL(file);
    } else {
      alert('Please select an image file.');
    }
  });

  cropImageBtn.addEventListener('click', () => {

    
    if (!cropper) return;

    cropper.getCroppedCanvas({
      width: 1080,
      height: 1080,
      fillColor: '#fff',
      imageSmoothingQuality: 'high',
    }).toBlob((blob) => {
      selectedImageFile = new File([blob], 'cropped-image.png', { type: 'image/png' });
console.log('Cropped image file created:', selectedImageFile);
      cropperContainer.style.display = 'none';
     if (cropper) {
  cropper.destroy();
  cropper = null;
}

      cropper = null;

      imagePreviewContainer.innerHTML = '';
      const imgEl = document.createElement('img');
      imgEl.src = URL.createObjectURL(selectedImageFile);
      imgEl.style.maxWidth = '100%';
      imgEl.style.maxHeight = '200px';
      //.innerHTML = `<img src="${croppedUrl}" style="max-width: 100%; max-height: 200px;" alt="Cropped Image">`;
      imagePreviewContainer.appendChild(imgEl);
      
    }, 'image/png');
  });
}


       async function getLikesCount(postId) {
      const { data, error } = await supabase
      .from('post_likes')
      .select('*', { count: 'exact' })
      .eq('post_id', postId);

    if (error) {
      console.error('Error fetching likes count:', error);
      return 0;
    }
    return data.length;
  }

  async function hasUserLiked(postId) {
   // const userId = localStorage.getItem('userId');
   // console.log('hasUserLiked called with postId:', postId, 'userId:', userId); // <--- here, before the Supabase call
    const { data, error } = await supabase
      .from('post_likes')
      .select('*')
      .eq('post_id', postId)
      .eq('user_id', userId)
      .maybeSingle();

      if (error) {
  console.error('Error checking user like:', error);
  return false;
}

    if (error && error.code !== 'PGRST116') {
      console.error('Error checking user like:', error);
      return false;
    }
    return !!data;
  }

  async function likePost(postId) {
     console.log('getLikesCount called with postId:', postId);  // <--- log here
   // const userId = localStorage.getItem('userId');
    const { error } = await supabase.from('post_likes').insert([{ post_id: postId, user_id: userId }]);
    if (error) console.error('Error liking post:', error);
  }

  async function unlikePost(postId) {
   // const userId = localStorage.getItem('userId');
    const { data, error } = await supabase
      .from('post_likes')
      .delete()
      .eq('post_id', postId)
      .eq('user_id', userId);
    if (error) console.error('Error unliking post:', error);
  }

  async function getComments(postId) {
    const { data, error } = await supabase
      .from('post_comments')
      .select('id, user_id, text, created_at')
      .eq('post_id', postId)
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Error fetching comments:', error);
      return [];
    }
    return data || [];
  }

   async function addComment(postId, commentText) {
   // const userId = localStorage.getItem('userId');
    const { error } = await supabase.from('post_comments').insert([{
      post_id: postId,
      user_id: userId,
      text: commentText
    }]);
    if (error) console.error('Error adding comment:', error);
  }

     async function fetchUserProfile(userId) {
     // const userId = localStorage.getItem('userId');
  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error) {
      console.error('Error fetching profile:', error);
      return null;
    }

    console.log('fetchUserProfile() - profile data:', data);
    playProfileMusic(userId);

    // Update profile picture if available
    if (data.profile_picture_url) {
      document.getElementById('profilePicture').src = data.profile_picture_url;
    } else {
      // fallback picture
      document.getElementById('profilePicture').src = 'default.jpg';
    }

    // Update display name if available
    if (data.display_name) {
      document.getElementById('usernameDisplay').textContent = data.display_name;
    }
    const stats = await getUserStats(userId);
    if (stats) {
      displayUserStats(stats);
    }

    return data;
  } catch (err) {
    console.error('Unexpected error fetching profile:', err);
    return null;
  }

  
}



    //  const stats = await getUserStats(userId);
async function getUserStats(userId) {
 // const userId = localStorage.getItem('userId');
  const { data, error } = await supabase
    .rpc('get_user_profile_stats', { input_user_id: userId });

  if (error) {
    console.error("Error fetching user stats:", error);
    return null;
  }

  // data will be an array with one object: [{ user_id, friends_count, followers_count, posts_count }]
  return data[0]; // return the single result
  
}

async function displayUserStats(stats) {
  // Example: update your UI with the stats
  if (!stats) return;

  document.getElementById('friendsCount').textContent = stats.friends_count;
  document.getElementById('followersCount').textContent = stats.followers_count;
  document.getElementById('postsCount').textContent = stats.posts_count;
}


      const friendsListEl = document.getElementById("friendsList");

  async function loadFriends(userId) {
  // console.log('Loading friends for userId:', userId);

  const friendsListEl = document.getElementById("friendsList");

  const { data, error } = await supabase
    .from('friends')
    .select(`
      id,
      user_id,
      friend_id,
      user:users!friends_user_id_fkey(id, username, profiles(profile_picture_url)),
      friend:users!friends_friend_id_fkey(id, username, profiles(profile_picture_url))
    `)
    .or(`user_id.eq.${userId},friend_id.eq.${userId}`);

  if (error) {
    console.error('Error fetching friends:', error);
    friendsListEl.textContent = 'Failed to load friends.';
    return;
  }

  if (!data || data.length === 0) {
   // console.log('No friends found for user:', userId);
    friendsListEl.textContent = 'No friends found.';
    return;
  }

  //('Friend data:', data);

  friendsListEl.innerHTML = ''; // Clear previous content

  data.forEach(item => {
    // Determine *who the friend is*, depending on whether I am user_id or friend_id
    const isUser = item.user_id === userId;
    const friend = isUser ? item.friend : item.user;

    const profilePic = friend.profiles?.profile_picture_url || 'https://fctswjvfkyolhiyzhusb.supabase.co/storage/v1/object/public/profile-pictures/standardProfile.jpg';

    const friendLink = document.createElement('a');
    friendLink.href = `profile.html?user=${friend.id}`;
    friendLink.style.display = 'flex';
    friendLink.style.alignItems = 'center';
    friendLink.style.gap = '8px';
    friendLink.style.textDecoration = 'none';
    friendLink.style.color = '#333';

    const img = document.createElement('img');
    img.src = profilePic;
    img.alt = `${friend.username}'s profile picture`;
    img.style.width = '40px';
    img.style.height = '40px';
    img.style.borderRadius = '50%';
    img.style.objectFit = 'cover';

    const usernameSpan = document.createElement('span');
    usernameSpan.textContent = friend.username;
    //usernameSpan = await createUsernameWithVerification(friend.id);
   // createUsernameWithVerification(friend.id);
    friendLink.appendChild(img);
    friendLink.appendChild(usernameSpan);
    friendsListEl.appendChild(friendLink);
  });
}

async function deletePost(postId) {
  try {
    // Step 1: Fetch the post to get the image path
    const { data: post, error: fetchError } = await supabase
      .from('posts')
      .select('media_url')  // <-- assuming your column is called 'image_path'
      .eq('id', postId)
      .single();

    if (fetchError) throw fetchError;

    const mediaUrl = post?.media_url;

    // TEMPORARY: Future feature, queue deletion before deletion (currently unused)
    // await supabase.from('deletionQueue').insert([{ post_id: postId, image_path: imagePath, created_at: new Date() }]);

    // Step 2: Delete the post from the database
    const { error: deletePostError } = await supabase
      .from('posts')
      .delete()
      .eq('id', postId);

    if (deletePostError) throw deletePostError;

    // Step 3: Delete the image from storage if it exists
   if (mediaUrl) {
      // Extract the file path relative to the bucket
      const filePath = mediaUrl.split('/post-images/')[1]; // ‚úÖ consistent name
      console.log('filePath to delete:', filePath); // ‚úÖ consistent name

console.log([filePath]);
      const { error: deleteImageError } = await supabase
        .storage
        .from('post-images')
        .remove([filePath]);

      if (deleteImageError) throw deleteImageError;
    }

    alert('Post and associated image deleted!');
  } catch (error) {
    console.error('Deletion failed:', error.message || error);
  alert(`Failed to delete post or its image: ${error.message || error}`);
  }
}


async function getCommentsCount(postId) {
  const { data, error, count } = await supabase
    .from('post_comments')
    .select('*', { count: 'exact', head: true })
    .eq('post_id', postId);

  if (error) throw error;
  return count;
}

async function uploadImage(file) {
  const fileName = `${Date.now()}_${file.name}`;
  const { data, error } = await supabase.storage
    .from('post-images') // Make sure this bucket exists in your Supabase project
    .upload(fileName, file);

  if (error) {
    console.error('Error uploading image:', error);
    throw error;
  }

  // Return the public URL of the uploaded image
  return `${supabaseUrl}/storage/v1/object/public/post-images/${fileName}`;
}

async function displayUsernameWithVerification(userId) {
  const { data, error } = await supabase
    .from('users')
    .select('id, username, verified')
    .eq('id', userId)
    .single(); // Get only this user's data

  if (error) {
    console.error("Error fetching user:", error);
    return;
  }

  const usernameEl = document.createElement("span");
  usernameEl.classList.add("username");
  usernameEl.textContent = data.username;

  if (data.verified === true) {
   // console.log("user verified")
    const verifiedIcon = document.createElement("img");
    verifiedIcon.src = "https://fctswjvfkyolhiyzhusb.supabase.co/storage/v1/object/public/profile-pictures/verified.png";
    verifiedIcon.alt = "Verified";
    verifiedIcon.style.width = "16px";
    verifiedIcon.style.height = "16px";
    verifiedIcon.style.marginLeft = "5px";
    verifiedIcon.style.verticalAlign = "middle";
    usernameEl.appendChild(verifiedIcon);
  }

  const userInfo = document.getElementById("usernameDisplay"); // Assuming you display the username here
  userInfo.innerHTML = ''; // Clear previous content
  userInfo.appendChild(usernameEl);
}

async function createUsernameWithVerification(userId) {
  const { data, error } = await supabase
    .from('users')
    .select('id, username, verified')
    .eq('id', userId)
    .single();

  if (error || !data) {
    console.error("Error fetching user:", error);
    const fallback = document.createElement("span");
    fallback.textContent = "Unknown User";
    return fallback;
  }

  const usernameEl = document.createElement("span");
  usernameEl.classList.add("username");
  usernameEl.textContent = data.username;

  if (data.verified) {
    const verifiedIcon = document.createElement("img");
    verifiedIcon.src = "https://fctswjvfkyolhiyzhusb.supabase.co/storage/v1/object/public/profile-pictures/verified.png";
    verifiedIcon.alt = "Verified";
    verifiedIcon.style.width = "16px";
    verifiedIcon.style.height = "16px";
    verifiedIcon.style.marginLeft = "5px";
    verifiedIcon.style.verticalAlign = "middle";
    usernameEl.appendChild(verifiedIcon);
  }

  return usernameEl;
}
      
async function setupImagePreview (){

    const postImageInput = document.getElementById('postImageInput');
const imagePreviewContainer = document.getElementById('imagePreviewContainer');

postImageInput.addEventListener('change', () => {
  imagePreviewContainer.innerHTML = ''; // Clear previous preview

  const file = postImageInput.files[0];
  if (file) {
    // Only show if file is an image
    if (file.type.startsWith('image/')) {
      const img = document.createElement('img');
      img.style.maxWidth = '100%';
      img.style.maxHeight = '200px';
      img.style.borderRadius = '8px';
      img.style.objectFit = 'contain';
      img.alt = 'Image preview';

      // Use FileReader to show preview
      const reader = new FileReader();
      reader.onload = e => {
        img.src = e.target.result;
        imagePreviewContainer.appendChild(img);
      };
      reader.readAsDataURL(file);
    } else {
      imagePreviewContainer.textContent = 'Selected file is not an image.';
    }
  }
});
}

async function openImagePostForm() {
  const postForm = document.getElementById('postForm');
  const textInput = document.getElementById('postText');
  const postImageInput = document.getElementById('postImageInput');
  const imagePreviewContainer = document.getElementById('imagePreviewContainer');

  // Reset form values
  textInput.value = '';
  postImageInput.value = '';
  imagePreviewContainer.innerHTML = '';

  // Call setupImagePreview here to attach event listener
 

  // Show the form
  postForm.style.display = 'block';
  
    setupImageCropper();

}


 async function loadPosts(userId) {
    const postsContainer = document.getElementById('postsContainer');
    if (!postsContainer) return;

    postsContainer.innerHTML = '';

    const { data: posts, error } = await supabase
      .from('posts')
      .select('id, body, media_url, created_at, user_id, user:users(username)')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching posts:', error);
      postsContainer.textContent = 'Failed to load posts.';
      return;
    }

    const userIds = [...new Set(posts.map(post => post.user_id))];

const { data: profiles } = await supabase
  .from('profiles')
  .select('user_id, profile_picture_url')
  .in('user_id', userIds);
  const profilePicMap = {};
profiles.forEach(profile => {
  profilePicMap[profile.user_id] = profile.profile_picture_url;
});

    if (!posts || posts.length === 0) {
      postsContainer.textContent = 'No posts yet.';
      return;
    }

    for (const post of posts) {
      const postEl = document.createElement('div');
      postEl.classList.add('post');
// --- USERNAME DISPLAY (above post) ---
    let usernameEl = document.createElement('div');
    usernameEl.textContent = post.user.username || 'Unknown User';
    usernameEl.classList.add('username');
    

  // create image element
const profilePic = document.createElement('img');

// Set src to the profile picture URL or default if missing
const defaultProfilePicUrl = 'default-profile.jpg'; // your default pic URL
profilePic.src = profilePicMap[post.user_id] || defaultProfilePicUrl;


profilePic.alt = `${post.user.username}'s profile picture`;
  profilePic.classList.add('profile-pic');


// Now create a container div for username and profile pic
const userInfo = document.createElement('div');
userInfo.style.display = 'flex';
userInfo.style.alignItems = 'center';

// Append the profile pic and username to the container
userInfo.appendChild(profilePic);
displayUsernameWithVerification(userId);

const {data: users} = await supabase



usernameEl = await createUsernameWithVerification(post.user_id);
userInfo.appendChild(usernameEl); //this is the username for the post

// Append userInfo container to post element
postEl.appendChild(userInfo);
   

      // Post body
      const contentEl = document.createElement('p');
      contentEl.textContent = post.body;
      contentEl.classList.add('post-text');
      postEl.appendChild(contentEl);
      

      // Post image if exists
      if (post.media_url) {
        const imgEl = document.createElement('img');
        imgEl.src = post.media_url;
        imgEl.alt = 'Post image';
        imgEl.style.maxWidth = '100%';
        imgEl.style.marginTop = '8px';
        postEl.appendChild(imgEl);
      }

      // Post timestamp
      const dateEl = document.createElement('small');
      dateEl.textContent = new Date(post.created_at).toLocaleString();
      postEl.appendChild(dateEl);

    // --- "..." BUTTON (top right) ---
    const moreBtn = document.createElement('button');
    moreBtn.textContent = '...';
    moreBtn.style.position = 'absolute';
    moreBtn.style.top = '8px';
    moreBtn.style.right = '8px';
    moreBtn.style.background = 'transparent';
    moreBtn.style.border = 'none';
    moreBtn.style.fontSize = '1.2em';
    moreBtn.style.cursor = 'pointer';
    moreBtn.style.color = 'black';
moreBtn.style.fontSize = '1.2em';
moreBtn.style.cursor = 'pointer';

    postEl.style.position = 'relative';

    // Dropdown container for options
    const dropdown = document.createElement('div');
    dropdown.style.position = 'absolute';
    dropdown.style.top = '30px';
    dropdown.style.right = '8px';
    dropdown.style.background = '#fff';
    dropdown.style.border = '1px solid #ccc';
    dropdown.style.padding = '5px 10px';
    dropdown.style.display = 'none';
    dropdown.style.zIndex = '100';


      const dropdownList = document.createElement('ul');
dropdownList.style.listStyle = 'none';      // Remove default bullets
dropdownList.style.padding = '0';           // Remove default padding
dropdownList.style.margin = '0';            // Remove default margin

const deleteItem = document.createElement('li');
deleteItem.textContent = 'Delete';
deleteItem.style.padding = '8px 12px';
deleteItem.style.cursor = 'pointer';
deleteItem.style.color = 'red';
deleteItem.onclick = async () => {
  if (confirm('Are you sure you want to delete this post?')) {
    await deletePost(post.id);
    await loadPosts(userId);
  }
};

const editItem = document.createElement('li');
editItem.textContent = 'Edit post';
editItem.style.padding = '8px 12px';
editItem.style.cursor = 'pointer';
editItem.style.color = 'black';
editItem.onclick = () => {
  console.log('Edit clicked');
};

const pinPost = document.createElement('li');
pinPost.textContent = 'Pin post';
pinPost.style.padding = '8px 12px';
pinPost.style.cursor = 'pointer';
pinPost.style.color = 'black';
editItem.onclick = () => {
  console.log('Edit clicked');
};

const updatePost = document.createElement('li');
updatePost.textContent = 'Update Post';
updatePost.style.padding = '8px 12px';
updatePost.style.cursor = 'pointer';
updatePost.style.color = 'black';
updatePost.onclick = () => {
  
};

const postToFeed = document.createElement('li');
postToFeed.textContent = 'Send to feed';
postToFeed.style.padding = '8px 12px';
postToFeed.style.cursor = 'pointer';
postToFeed.style.color = 'black';
postToFeed.onclick = () => {
  console.log("feed clicked");
 sendPostToFeed(post.id);
  
};

// Optional: hover effect for better UX
[deleteItem, editItem].forEach(item => {
  item.onmouseover = () => item.style.backgroundColor = '#f0f0f0';
  item.onmouseout = () => item.style.backgroundColor = 'transparent';
});

dropdownList.appendChild(pinPost);
dropdownList.appendChild(editItem);
dropdownList.appendChild(updatePost);
dropdownList.appendChild(postToFeed);
dropdownList.appendChild(deleteItem);

dropdown.appendChild(dropdownList);

// Toggle dropdown visibility on moreBtn click
moreBtn.onclick = () => {
  dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
};
    // Close dropdown if clicked outside
    document.addEventListener('click', (e) => {
      if (!postEl.contains(e.target)) {
        dropdown.style.display = 'none';
      }
    });

    postEl.appendChild(moreBtn);
    postEl.appendChild(dropdown);


      // Likes
      const likesCount = await getLikesCount(post.id);
  let likedByUser = await hasUserLiked(post.id);

 // New text-like clickable element
const likeText = document.createElement('span');
likeText.textContent = likedByUser ? `‚ù§Ô∏è ${likesCount}` : `ü§ç ${likesCount}`;
likeText.style.marginTop = '8px';
likeText.style.cursor = 'pointer';          // Makes it look clickable
likeText.style.userSelect = 'none';         // Optional: disables text selection on click
likeText.style.fontSize = '1.1em';          // Slightly larger text for emphasis

likeText.onclick = async () => {
  if (likedByUser) {
    await unlikePost(post.id);
    likedByUser = false;
  } else {
    await likePost(post.id);
    likedByUser = true;
  }
  const newLikesCount = await getLikesCount(post.id);
  likeText.textContent = likedByUser ? `‚ù§Ô∏è ${newLikesCount}` : `ü§ç ${newLikesCount}`;
};
postEl.appendChild(likeText);

  // Comments section
  const comments = await getComments(post.id);
const commentCount = document.createElement('span');
commentCount.textContent = ` ${comments.length}`; // Initial count


  const commentsList = document.createElement('div');
  commentsList.style.marginTop = '8px';
  commentsList.style.borderTop = '1px solid #ccc';
  commentsList.style.paddingTop = '6px';
  commentsList.style.display = 'none';

  comments.forEach(comment => {
    const commentEl = document.createElement('div');
    commentEl.textContent = comment.text;
    commentEl.style.fontSize = '0.9em';
    commentEl.style.marginBottom = '4px';
    commentsList.appendChild(commentEl);
  });

  

  // Create the comment toggle button


// Comment form (hidden initially)
const commentForm = document.createElement('div');
commentForm.style.display = 'none'; // Hidden initially
commentForm.style.marginTop = '6px';
//commentForm.style.display = 'flex';
commentForm.style.alignItems = 'center';

const commentsCount = await getCommentsCount(post.id);

const commentToggleEmoji = document.createElement('span');
commentToggleEmoji.textContent = `üí¨ ${commentsCount}`;
commentToggleEmoji.style.cursor = 'pointer';
commentToggleEmoji.style.marginLeft = '12px';
commentToggleEmoji.style.fontSize = '1.3em';
commentToggleEmoji.style.userSelect = 'none';

  // Add comment input
  const commentInput = document.createElement('input');
commentInput.type = 'text';
commentInput.placeholder = 'Add a comment...';
commentInput.style.flex = '1';

const commentBtn = document.createElement('button');
commentBtn.textContent = 'Post';
commentBtn.style.marginLeft = '6px';
postEl.appendChild(commentToggleEmoji);
postEl.appendChild(commentsList);
commentForm.appendChild(commentInput);
commentForm.appendChild(commentBtn);
postEl.appendChild(commentForm);



commentToggleEmoji.onclick = () => {
  const isVisible = commentsList.style.display === 'block';
  commentsList.style.display = isVisible ? 'none' : 'block';
  commentForm.style.display = isVisible ? 'none' : 'flex';
};



  commentBtn.onclick = async () => {
    if (commentInput.value.trim() !== '') {
      await addComment(post.id, commentInput.value.trim());
      commentInput.value = '';

      // Reload comments after adding new one
      const updatedComments = await getComments(post.id);
      commentsList.innerHTML = '';
      updatedComments.forEach(c => {
        const cEl = document.createElement('div');
        cEl.textContent = c.text;
        cEl.style.fontSize = '0.9em';
        cEl.style.marginBottom = '4px';
        commentsList.appendChild(cEl);

        
      });
       // ‚úÖ Refresh comment count after adding
       
   
    commentToggleEmoji.textContent = `üí¨ ${newCommentsCount}`;
       commentCount.textContent = ` ${updatedComments.length}`;
    }
  };
 
postEl.appendChild(commentForm);
  commentForm.appendChild(commentInput);
  commentForm.appendChild(commentBtn);

  postEl.appendChild(commentForm);

  postsContainer.appendChild(postEl);
    }
  }

 async function sendPostToFeed(postId) {
  //console.log('Send to feed clicked for post ID:', postId);

  // Fetch the post from 'posts' table
  const { data: post, error } = await supabase
    .from('posts')
    .select('*')
    .eq('id', postId)
    .single();

  if (error || !post) {
    alert('Failed to find post.');
    return;
  }

 // console.log('Post data to send:', post);

  // Optional: check if post already in feed
  const { data: existingFeed, error: checkError } = await supabase
    .from('feed')
    .select('id')
    .eq('post_id', postId)
    .maybeSingle();

  //  console.log('existingFeed:', existingFeed, 'checkError:', checkError);

  if (checkError && checkError.code !== 'PGRST116') { // 'PGRST116' = no rows found
    console.error(checkError);
    alert('Error checking feed.');
    return;
  }
  if (existingFeed) {
    alert('Post already in feed.');
    return;
  }

  // Insert into 'feed' table
  const { error: feedError } = await supabase
    .from('feed')
    .insert([{
      post_id: post.id,
      user_id: post.user_id,
      media_url: post.media_url,
      body: post.body,
      // created_at: post.created_at // optional
    }]);

  if (feedError) {
    alert('Failed to send to feed.');
    console.error(feedError);
  } else {
    alert('Post sent to feed!');
  }
}

async function loadFeed() {
 // console.log("loadFeed")
  // Fetch all feed entries, ordered by feed_order and created_at
  const { data: feedData, error } = await supabase
    .from('feed')
    .select('id, post_id, user_id, media_url, body, created_at, pinned, feed_order')
    .order('feed_order', { ascending: false })
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error loading feed:', error);
    alert('Failed to load feed.');
    return;
  }

  const feedContainer = document.getElementById('feedContainer');
  feedContainer.innerHTML = ''; // Clear previous content



  // Create a wrapper div with grid styles
  const gridWrapper = document.createElement('div');
  gridWrapper.style.display = 'grid';
  gridWrapper.style.gridTemplateColumns = 'repeat(3, 1fr)';
  gridWrapper.style.gap = '10px';

  const baseURL = 'https://fctswjvfkyolhiyzhusb.supabase.co/storage/v1/object/public';



  feedData.forEach(item => {
    if (!item.media_url) return; // Skip if no image URL
//console.log("media " + item.media_url);

const fullUrl = baseURL + item.media_url; // Declare first
 // console.log("media " + item.media_url);
 // console.log('Final image URL:', fullUrl);

    
    const imgDiv = document.createElement('div');
    imgDiv.style.position = 'relative';
    imgDiv.classList.add('feed-item');



  
    const img = document.createElement('img');
    img.src = item.media_url;
    img.alt = item.body || 'Feed image';
    img.style.width = '100%';
    img.style.objectFit = 'cover';
    img.style.borderRadius = '8px';
    img.alt = item.body || 'Feed image';

     // ‚úÖ Create the overlay div with delete button
    const overlay = document.createElement('div');
    overlay.classList.add('hover-overlay');

    feedContainer.appendChild(img);
    

    imgDiv.appendChild(img);
    gridWrapper.appendChild(imgDiv);
    
  });

  

  feedContainer.appendChild(gridWrapper);

 // console.log('feedData length:', feedData.length);
//console.log('Media URLs:', feedData.map(item => item.media_url));

}



   // Setup tab switching
  function setupTabs() {
  const tabsContainer = document.getElementById('postTabs');
  const postsContainer = document.getElementById('postsContainer');
  const profileContainer = document.getElementById('profileContainer'); // make sure this exists
  const feedContainer = document.getElementById('feedContainer'); // make sure this exists
  const userId = localStorage.getItem('userId');

  tabsContainer.addEventListener('click', async (event) => {
    if (!event.target.classList.contains('tab')) return;

    const clickedTab = event.target;
    if (clickedTab.classList.contains('active')) {
      return; // already active, do nothing
    }

    // Remove active class from all tabs
    document.querySelectorAll('#postTabs .tab').forEach(tab => tab.classList.remove('active'));

    // Add active class to clicked tab
    clickedTab.classList.add('active');

    const selectedTab = clickedTab.getAttribute('data-tab');

    // Hide all content containers by default
    postsContainer.style.display = 'none';
    if (profileContainer) profileContainer.style.display = 'none';
    if (feedContainer) feedContainer.style.display = 'none';

    // Show and load content based on selected tab
    if (selectedTab === 'posts') {
      postsContainer.style.display = 'block';
      await loadPosts(userId);

    } else if (selectedTab === 'profile') {
      if (profileContainer) {
        profileContainer.style.display = 'block';
        await loadDraggableImages(userId);
      }

    } else if (selectedTab === 'feed') {
      console.log("feed pressed")
      console.log(feedContainer);
      if (feedContainer) {
        feedContainer.style.display = 'grid';
        await loadFeed();
        showFeedContainer();
        console.log('Feed loaded!');
      }
    }
  });
}
function showFeedContainer() {
  console.log("feed showing!")
  const feedContainer = document.getElementById('feedContainer');
  if (feedContainer) {
    feedContainer.style.display = 'block';
    feedContainer.style.visibility = 'visible';
    feedContainer.style.opacity = '1';
  }
}


      async function init() {

      

        const userId = localStorage.getItem('userId');
       // console.log('init() - userId:', userId);  // Log userId here
        if (!userId) {
          alert('No user ID found. Please log in.');
          window.location.href = 'login.html';
          return;
        }

         document.getElementById('postsContainer').style.display = 'block';

       // await fetchUserProfile(userId);
       // await loadFriends(userId);
        await loadPosts(userId);

        setupTabs();

    

        const tabsContainer = document.getElementById('postTabs');
 const postsContainer = document.getElementById('postsContainer');
        const fab = document.getElementById('fab');
  const fabOptions = document.getElementById('fabOptions');
  const postForm = document.getElementById('postForm');
  const postText = document.getElementById('postText');
  const postImageInput = document.getElementById('postImageInput');
  //let selectedImageFile = null;


  function getActiveTab() {
  const activeTab = document.querySelector('#postTabs .tab.active');
  return activeTab ? activeTab.dataset.tab : null;
}

function clearFabOptions() {
  fabOptions.innerHTML = '';
}

function createFabButton(text, id, clickHandler) {
  const btn = document.createElement('button');
  btn.classList.add('fab-option-btn');
  btn.id = id;
  btn.textContent = text;
  btn.addEventListener('click', clickHandler);
  return btn;
}

function setupFabOptionsForTab(tab) {
  clearFabOptions();
  console.log("fab options loaded")
   
    fabOptions.appendChild(createFabButton('‚úèÔ∏è Edit Profile', 'editProfileFabBtn', () => {
      fabOptions.style.display = 'none';
      document.getElementById('editProfileBtn').click();  // Trigger existing edit profile button
    }));


  if (tab === 'posts') {
    fabOptions.appendChild(createFabButton('üìÑ New Text Post', 'newTextPostBtn', () => {
      postText.style.display = 'block';
      postImageInput.style.display = 'none';
      postImageInput.value = null;
      postForm.style.display = 'block';
      fabOptions.style.display = 'none';
    }));

    fabOptions.appendChild(createFabButton('üñºÔ∏è New Image Post', 'newImagePostBtn', () => {
  postText.style.display = 'block';
  postText.value = '';
  postImageInput.style.display = 'block';
  postForm.style.display = 'block';
  fabOptions.style.display = 'none';

  openImagePostForm(); // handles clearing, showing form, attaching listeners
  postImageInput.click(); // triggers file picker
}));
  } else if (tab === 'feed') {
    
    fabOptions.appendChild(createFabButton('üîÑ Refresh Feed', 'refreshFeedBtn', () => {
      fabOptions.style.display = 'none';
      // Your refresh feed logic here
      
      console.log('Feed refreshed!');
    }));

    fabOptions.appendChild(createFabButton('‚öôÔ∏è Feed Settings', 'feedSettingsBtn', () => {
      fabOptions.style.display = 'none';
      // Your feed settings logic here
      console.log('Feed settings opened!');
    }));

  } else if (tab === 'profile') {
   
    fabOptions.appendChild(createFabButton('üìå Add Draggable Image', 'addDraggableImageBtn', () => {
    fabOptions.style.display = 'none';
    // Trigger the hidden file input for image selection
    const draggableInput = document.createElement('input');
    draggableInput.type = 'file';
    draggableInput.accept = 'image/*';
    draggableInput.style.display = 'none';
    document.body.appendChild(draggableInput);

    draggableInput.onchange = (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const img = document.createElement('img');
        img.src = e.target.result;
        img.style.position = 'absolute';
        img.style.top = '100px'; // initial position
        img.style.left = '100px';
        img.style.width = '150px';
        img.style.height = '150px';
        img.style.cursor = 'move';
        img.style.zIndex = '9999';
        img.id = 'draggableImage';

        document.body.appendChild(img);

         // Create Save button
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'Save Position';
      saveBtn.style.position = 'fixed';
      saveBtn.style.bottom = '80px';
      saveBtn.style.right = '20px';
      document.body.appendChild(saveBtn);

      saveBtn.onclick = async () => {
  try {
    // Get current position before uploading/saving
    const positionTop = parseInt(img.style.top) || 0;
    const positionLeft = parseInt(img.style.left) || 0;

    // Upload the file, get the URL
    const imageUrl = await uploadDraggableImage(file);

    // Save the image URL and position
    console.log(imageUrl, positionTop, positionLeft);
    await saveDraggableImage(imageUrl, positionTop, positionLeft);

    


    // Optional: cleanup UI
    saveBtn.remove();
    img.remove();
console.log("Loading image at URL:", imageUrl);
    loadDraggableImages(imageUrl, positionTop, positionLeft);
  } catch (error) {
    console.error('Error uploading or saving image:', error);
  }


};
    

        // Drag functionality
        let isDragging = false;
        let offsetX, offsetY;

        img.addEventListener('mousedown', (e) => {
          isDragging = true;
          offsetX = e.clientX - img.offsetLeft;
          offsetY = e.clientY - img.offsetTop;
          img.style.transition = 'none'; // disable transition while dragging
        });

        window.addEventListener('mouseup', () => {
          isDragging = false;
          img.style.transition = ''; // restore transition
        });

        window.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          img.style.left = (e.clientX - offsetX) + 'px';
          img.style.top = (e.clientY - offsetY) + 'px';
        });
      };

      reader.readAsDataURL(file);

      // Clean up
      document.body.removeChild(draggableInput);
    };

    draggableInput.click();
  }));

    fabOptions.appendChild(createFabButton('üñºÔ∏è Change Background', 'changeBackgroundFabBtn', () => {
      fabOptions.style.display = 'none';
      document.getElementById('changeBackgroundButton').click();  // Trigger existing change background button
    }));
  }
}


   // Show text post form
        newTextPostBtn.addEventListener('click', () => {
          postText.style.display = 'block';
          postImageInput.style.display = 'none';
          postImageInput.value = null;
          postForm.style.display = 'block';
          fabOptions.style.display = 'none';
        });

        // Show image post form
        newImagePostBtn.addEventListener('click', () => {
          postText.style.display = 'none';
          postText.value = '';
          postImageInput.style.display = 'block';
          postForm.style.display = 'block';
          fabOptions.style.display = 'none';

        });

       

 fab.onclick = () => {
  const activeTab = getActiveTab();
  if (fabOptions.style.display === 'flex') {
    fabOptions.style.display = 'none';
  } else {
    setupFabOptionsForTab(activeTab);
    fabOptions.style.display = 'flex';
  }
};

  document.getElementById('newTextPostBtn').onclick = () => {
    selectedImageFile = null;
    postImageInput.style.display = 'none';
    postForm.style.display = 'block';
    fabOptions.style.display = 'none';
  };

  document.getElementById('newImagePostBtn').onclick = () => {
    postImageInput.style.display = 'block';
    postImageInput.click();
    postImageInput.onchange = () => {
      selectedImageFile = postImageInput.files[0];
      postForm.style.display = 'block';
      fabOptions.style.display = 'none';
    };
  };



  document.getElementById('cancelPostBtn').onclick = () => {
    postForm.style.display = 'none';
    postText.value = '';
    postImageInput.value = '';
    selectedImageFile = null;

    cancelPostBtn.addEventListener('click', () => {
  imagePreviewContainer.innerHTML = '';
  postImageInput.value = '';  // Clear file input
  document.getElementById('postText').value = '';
});
  };

  document.getElementById('submitPostBtn').onclick = async () => {
    console.log('Submit clicked. Selected image file:', selectedImageFile);

    const userId = localStorage.getItem('userId');
    const text = document.getElementById('postText').value.trim();
  const fileInput = document.getElementById('postImageInput');

  let mediaUrl = null;
 let imageUrl = null;

  if (fileInput.files.length > 0) {
    // Upload the image to your storage and get the public URL
    mediaUrl = await uploadImage(fileInput.files[0]);
    console.log("Uploaded image URL:", imageUrl);
  }
    if (!userId) {
      alert('No user ID found. Please log in.');
      return;
    }
// ‚úÖ Upload cropped image if it exists
  if (selectedImageFile) {
    const fileExt = selectedImageFile.name.split('.').pop();
    const fileName = `${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;

    const { data, error } = await supabase.storage
      .from('post-images')
      .upload(fileName, selectedImageFile, { upsert: true });

    if (error) {
      alert('Image upload failed.');
      console.error(error);
      return;
    }
  }
  
    // Upload image if selected
    if (selectedImageFile) {
  const fileExt = selectedImageFile.name.split('.').pop();
const fileName = `${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;

const { data, error } = await supabase.storage
  .from('post-images')
  .upload(fileName, selectedImageFile, { upsert: true });

if (error) {
  alert('Image upload failed.');
  console.error(error);
  return;
}

const { data: publicUrlData } = supabase.storage.from('post-images').getPublicUrl(fileName);
imageUrl = publicUrlData.publicUrl;
}

    const { error: insertError } = await supabase.from('posts').insert([{
      user_id: userId,
      body: postText.value.trim(),
      media_url: imageUrl || null
    }]);

    if (insertError) {
      alert('Failed to create post.');
      console.error(insertError);
      return;
    }

   ;


    postForm.style.display = 'none';
    postText.value = '';
    postImageInput.value = '';
    selectedImageFile = null;

    await loadPosts(userId); // refresh posts
  };
  setupTabs();


        await fetchUserProfile(userId);
        await loadFriends(userId);
        await loadPosts(userId); // ‚úÖ CALLING loadPosts() here
      }

      

      document.addEventListener("DOMContentLoaded", () => {
  init();
});
    </script>
  </div>
</body>

</html>